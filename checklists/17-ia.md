# üìã Chapitre 17 - Intelligence Artificielle (Agent IA)

**Status :** ‚úÖ V1 IMPL√âMENT√â + V2 SPEC READY
**Tests :** 12/30 (40%)
**Priorit√© :** üü° Moyenne
**Bonus :** ‚úÖ **COMPL√âT√â** - Config IA centralis√©e sur `/dashboard/settings/integrations?tab=ai`

---

## Agent IA - Fonctionnalit√©s (6 tests)

| # | Test | Statut | Remarques |
|---|------|--------|-----------|
| 17.1 | **Test** : D√©tection de doublons organisations | ‚úÖ | POST /ai/duplicates/detect (async) |
| 17.2 | **Test** : Enrichissement automatique donn√©es | ‚úÖ | POST /ai/enrich/organisations |
| 17.3 | **Test** : Contr√¥le qualit√© donn√©es | ‚úÖ | POST /ai/quality/check |
| 17.4 | Suggestions stock√©es en DB | ‚úÖ | Table ai_suggestions avec 5 statuts |
| 17.5 | **Test** : Cache optimise co√ªts API | ‚úÖ | Table ai_cache avec hit_count |
| 17.6 | Dashboard statistiques IA | ‚úÖ | /dashboard/ai avec KPIs |

## Gestion des Suggestions (5 tests)

| # | Test | Statut | Remarques |
|---|------|--------|-----------|
| 17.7 | **Test** : Approuver suggestion individuelle | ‚úÖ | POST /ai/suggestions/:id/approve |
| 17.8 | **Test** : Rejeter suggestion | ‚úÖ | POST /ai/suggestions/:id/reject |
| 17.9 | **Test** : Batch approve (masse) | ‚úÖ | POST /ai/suggestions/batch/approve |
| 17.10 | **Test** : Preview avant application | ‚úÖ | GET /ai/suggestions/:id/preview |
| 17.11 | Notifications suggestions | ‚úÖ | notify_on_suggestions dans config |

## Configuration & Monitoring (4 tests)

| # | Test | Statut | Remarques |
|---|------|--------|-----------|
| 17.12 | Configuration multi-providers | ‚úÖ | Claude, OpenAI, Ollama, Custom |
| 17.13 | **Test** : Budget quotidien/mensuel | ‚¨ú | daily_budget_usd, monthly_budget_usd (√† tester) |
| 17.14 | **Test** : Seuils de confiance (auto-apply) | ‚¨ú | auto_apply_confidence_threshold (√† tester) |
| 17.15 | Historique ex√©cutions (logs) | ‚úÖ | Table ai_executions avec m√©triques |

## Autofill Pr√©dictif - Smart Fill (6 tests)

| # | Test | Statut | Remarques |
|---|------|--------|-----------|
| 17.16 | **Test** : Pattern email d√©duit contacts existants | ‚¨ú | POST /ai/autofill - Inf√©rence prenom.nom vs f.nom |
| 17.17 | **Test** : Normalisation t√©l√©phone E.164 | ‚¨ú | Format +33123456789 automatique |
| 17.18 | **Test** : Pays/langue d√©duits du domaine | ‚¨ú | .fr ‚Üí FR + langue fr |
| 17.19 | Pills inline sous inputs (Tab/Enter) | ‚¨ú | Accepter/rejeter suggestions |
| 17.20 | Bouton "‚ö° Remplir pour moi" dans formulaires | ‚¨ú | PersonForm + OrganisationForm |
| 17.21 | Tra√ßabilit√© suggestions accept√©es/rejet√©es | ‚¨ú | Journal who/when/field/source |

---

## üìä Analyse de l'Impl√©mentation Backend

### ‚úÖ Architecture Agent IA

**Fichiers principaux** :
- [services/ai_agent.py](../crm-backend/services/ai_agent.py) - Service principal (AIAgentService)
- [models/ai_agent.py](../crm-backend/models/ai_agent.py) - 4 mod√®les DB (Suggestion, Execution, Config, Cache)
- [api/routes/ai_agent.py](../crm-backend/api/routes/ai_agent.py) - Routes API (/ai/*)
- [schemas/ai_agent.py](../crm-backend/schemas/ai_agent.py) - Sch√©mas Pydantic

### ‚úÖ Mod√®les de Base de Donn√©es

#### 1. AISuggestion (Table: ai_suggestions)
**Colonnes cl√©s** :
```python
type: AISuggestionType  # duplicate_detection, data_enrichment, data_quality, etc.
status: AISuggestionStatus  # pending, approved, rejected, applied, expired
entity_type: String  # organisation, person
entity_id: Integer
suggestion_data: JSON  # Donn√©es structur√©es de la suggestion
confidence_score: Float  # 0-1
ai_provider: AIProvider  # claude, openai, ollama
ai_model: String  # ex: claude-3-5-sonnet-20241022
prompt_tokens: Integer
completion_tokens: Integer
auto_applied: Boolean
expires_at: DateTime
```

**Types de suggestions** (AISuggestionType) :
- `duplicate_detection` : D√©tection de doublons
- `data_enrichment` : Enrichissement de donn√©es
- `data_quality` : Contr√¥le qualit√©
- `data_correction` : Correction de donn√©es
- `workflow_suggestion` : Suggestion de workflow
- `categorization` : Cat√©gorisation automatique
- `contact_extraction` : Extraction de contacts

**Statuts** (AISuggestionStatus) :
- `pending` : En attente de validation
- `approved` : Approuv√©e par l'utilisateur
- `rejected` : Rejet√©e
- `applied` : Appliqu√©e automatiquement
- `expired` : Expir√©e (non trait√©e)

#### 2. AIExecution (Table: ai_executions)
**Colonnes cl√©s** :
```python
task_type: AITaskType  # duplicate_scan, bulk_enrichment, quality_check
status: AIExecutionStatus  # pending, running, success, failed, partial, cancelled
started_at: DateTime
completed_at: DateTime
duration_seconds: Float
total_items_processed: Integer
total_suggestions_created: Integer
total_suggestions_applied: Integer
total_prompt_tokens: Integer
total_completion_tokens: Integer
estimated_cost_usd: Float
execution_logs: JSON  # Array de logs
error_message: Text
triggered_by: Integer (FK users)
```

**Types de t√¢ches** (AITaskType) :
- `duplicate_scan` : Scan de doublons
- `bulk_enrichment` : Enrichissement en masse
- `quality_check` : V√©rification qualit√©
- `auto_categorize` : Cat√©gorisation auto
- `contact_extraction` : Extraction contacts

#### 3. AIConfiguration (Table: ai_configurations)
**Configuration active** :
```python
name: String (unique)
is_active: Boolean
ai_provider: AIProvider  # claude, openai, ollama, custom
ai_model: String
auto_apply_enabled: Boolean
auto_apply_confidence_threshold: Float (0.95)
duplicate_similarity_threshold: Float (0.85)
quality_score_threshold: Float (0.70)
max_suggestions_per_execution: Integer (100)
daily_budget_usd: Float
monthly_budget_usd: Float
notify_on_suggestions: Boolean
encrypted_anthropic_key: Text  # Cl√© chiffr√©e
encrypted_openai_key: Text
```

**Providers support√©s** :
- ‚úÖ **Claude (Anthropic)** : claude-3-5-sonnet-20241022
- ‚úÖ **OpenAI** : GPT-4, GPT-3.5
- ‚úÖ **Ollama** : Mod√®les locaux
- ‚úÖ **Custom** : API personnalis√©e

#### 4. AICache (Table: ai_cache)
**Optimisation des co√ªts** :
```python
cache_key: String(64) unique  # Hash de la requ√™te
request_type: String  # duplicate_detection, enrichment, etc.
request_data: JSON
response_data: JSON
hit_count: Integer  # Nombre d'utilisations
last_hit_at: DateTime
expires_at: DateTime
```

‚úÖ **√âconomies de co√ªts** : Cache √©vite de r√©interroger l'API pour les m√™mes requ√™tes.

---

## üìä Analyse de l'Impl√©mentation Frontend

### ‚úÖ Pages Dashboard

#### 1. /dashboard/ai (Page principale)
**Fichier** : [app/dashboard/ai/page.tsx](../crm-frontend/app/dashboard/ai/page.tsx)

**Composants** :
- **AIStatCard** : KPIs (pending, approved, co√ªt, cache hit rate)
- **AIExecutionsList** : Historique des 10 derni√®res ex√©cutions
- **Actions rapides** :
  - D√©tecter doublons
  - Enrichir organisations
  - Contr√¥le qualit√©

**M√©triques affich√©es** :
```typescript
stats.pending_suggestions      // Suggestions en attente
stats.approved_suggestions     // Approuv√©es
stats.applied_suggestions      // Appliqu√©es automatiquement
stats.total_cost_usd          // Co√ªt total
stats.cache_hit_rate          // Taux de cache (0-1)
```

#### 2. /dashboard/ai/suggestions (Liste des suggestions)
**Fichier** : [app/dashboard/ai/suggestions/page.tsx](../crm-frontend/app/dashboard/ai/suggestions/page.tsx)

**Features** :
- Filtres : status, type, entity_type, min_confidence
- Table avec colonnes : Type, Entit√©, Confiance, Statut, Actions
- Actions : Approuver, Rejeter, Preview
- Batch operations (approuver/rejeter en masse)

#### 3. /dashboard/ai/config (Configuration)
**Fichier** : [app/dashboard/ai/config/page.tsx](../crm-frontend/app/dashboard/ai/config/page.tsx)

**Param√®tres configurables** :
- Provider IA (Claude, OpenAI, Ollama)
- Mod√®le AI
- Seuils de confiance
- Budget quotidien/mensuel
- Auto-apply enabled
- Notifications

### ‚úÖ React Hooks (useAI.ts)

**Fichier** : [hooks/useAI.ts](../crm-frontend/hooks/useAI.ts)

**Queries disponibles** :
```typescript
useAISuggestions(filters)           // Liste suggestions
useAISuggestion(id)                 // D√©tail suggestion
useEntitySuggestions(type, id)      // Suggestions pour une entit√©
usePreviewSuggestion(id)            // Preview avant application
useAIStatistics()                   // Stats globales (refresh 30s)
useAIExecutions(filters)            // Historique ex√©cutions
useAIConfig()                       // Configuration active
```

**Mutations disponibles** :
```typescript
useDetectDuplicates()               // Lancer d√©tection
useEnrichOrganisations()            // Lancer enrichissement
useCheckQuality()                   // Lancer contr√¥le qualit√©
useApproveSuggestion()              // Approuver
useRejectSuggestion()               // Rejeter
useBatchApproveSuggestions()        // Approuver en masse
useBatchRejectSuggestions()         // Rejeter en masse
useUpdateAIConfig()                 // Mettre √† jour config
```

**Custom hooks utilitaires** :
```typescript
usePendingSuggestionsCount()        // Compteur pour badges
useIsAIConfigured()                 // V√©rifie si API key configur√©e
```

### ‚úÖ Composants UI

**Cr√©√©s** :
- [components/ai/AIStatCard.tsx](../crm-frontend/components/ai/AIStatCard.tsx) - Carte KPI
- [components/ai/AIExecutionsList.tsx](../crm-frontend/components/ai/AIExecutionsList.tsx) - Liste ex√©cutions
- [components/ai/SuggestionsTable.tsx](../crm-frontend/components/ai/SuggestionsTable.tsx) - Table suggestions
- [components/ai/SuggestionPreviewModal.tsx](../crm-frontend/components/ai/SuggestionPreviewModal.tsx) - Preview
- [components/ai/OrganisationAISuggestions.tsx](../crm-frontend/components/ai/OrganisationAISuggestions.tsx) - Suggestions par org

---

## üéØ Routes API Backend

### T√¢ches IA (Asynchrones)

| Endpoint | M√©thode | Description | Status |
|----------|---------|-------------|--------|
| `/ai/duplicates/detect` | POST | D√©tecter doublons | ‚úÖ 202 |
| `/ai/enrich/organisations` | POST | Enrichir organisations | ‚úÖ 202 |
| `/ai/quality/check` | POST | Contr√¥le qualit√© | ‚úÖ 202 |

**Params** :
```json
{
  "entity_type": "organisation",
  "limit": 100,
  "filters": {},
  "auto_apply": false
}
```

**Response** (AIExecution) :
```json
{
  "id": 42,
  "task_type": "duplicate_scan",
  "status": "pending",
  "created_at": "2025-10-27T10:00:00Z"
}
```

### Suggestions

| Endpoint | M√©thode | Description | Status |
|----------|---------|-------------|--------|
| `/ai/suggestions` | GET | Liste suggestions (filtres) | ‚úÖ |
| `/ai/suggestions/:id` | GET | D√©tail suggestion | ‚úÖ |
| `/ai/suggestions/:id/preview` | GET | Preview changements | ‚úÖ |
| `/ai/suggestions/:id/approve` | POST | Approuver | ‚úÖ |
| `/ai/suggestions/:id/reject` | POST | Rejeter | ‚úÖ |
| `/ai/suggestions/batch/approve` | POST | Approuver en masse | ‚úÖ |
| `/ai/suggestions/batch/reject` | POST | Rejeter en masse | ‚úÖ |
| `/ai/suggestions/:entity_type/:id` | GET | Par entit√© | ‚úÖ |

**Filtres GET /ai/suggestions** :
```
?status=pending
&type=duplicate_detection
&entity_type=organisation
&entity_id=123
&min_confidence=0.8
&max_confidence=1.0
&limit=50
&offset=0
```

### Statistiques & Configuration

| Endpoint | M√©thode | Description | Status |
|----------|---------|-------------|--------|
| `/ai/statistics` | GET | Stats globales | ‚úÖ |
| `/ai/executions` | GET | Historique ex√©cutions | ‚úÖ |
| `/ai/executions/:id` | GET | D√©tail ex√©cution | ‚úÖ |
| `/ai/config` | GET | Config active | ‚úÖ |
| `/ai/config` | PATCH | Mettre √† jour config | ‚úÖ |

**Response GET /ai/statistics** :
```json
{
  "pending_suggestions": 15,
  "approved_suggestions": 120,
  "applied_suggestions": 90,
  "rejected_suggestions": 10,
  "total_executions": 50,
  "total_cost_usd": 12.45,
  "cache_hit_rate": 0.77,
  "avg_confidence_score": 0.89
}
```

---

## üöÄ Fonctionnalit√©s Impl√©ment√©es

### ‚úÖ 1. D√©tection de Doublons (Duplicate Detection)

**Service** : `AIAgentService.detect_duplicates()`

**Algorithme** :
1. Charger organisations avec filtres
2. Pour chaque paire :
   - Calculer similarit√© (nom, email, t√©l√©phone, adresse)
   - Si similarit√© > `duplicate_similarity_threshold` (0.85)
   - Cr√©er AISuggestion type=duplicate_detection
3. Si confidence > `auto_apply_confidence_threshold` (0.95)
   - Appliquer automatiquement (merge)

**Exemple suggestion** :
```json
{
  "type": "duplicate_detection",
  "entity_type": "organisation",
  "entity_id": 123,
  "title": "Doublon potentiel d√©tect√©",
  "description": "Organisation 'ACME Corp' similaire √† 'ACME Corporation'",
  "suggestion_data": {
    "duplicate_id": 124,
    "similarity_score": 0.92,
    "matching_fields": ["name", "email"]
  },
  "confidence_score": 0.92
}
```

### ‚úÖ 2. Enrichissement de Donn√©es (Data Enrichment)

**Service** : `AIAgentService.enrich_organisations()`

**Fonctionnalit√©s** :
- Compl√©ter champs manquants (SIRET, secteur, taille)
- Normaliser adresses
- Enrichir via APIs externes (si configur√©es)
- Suggestions de cat√©gorisation

**Exemple suggestion** :
```json
{
  "type": "data_enrichment",
  "entity_type": "organisation",
  "entity_id": 123,
  "title": "Enrichissement de donn√©es disponible",
  "description": "SIRET et secteur d'activit√© trouv√©s",
  "suggestion_data": {
    "siret": "12345678900001",
    "sector": "Informatique",
    "size": "50-200",
    "source": "api_infogreffe"
  },
  "confidence_score": 0.88
}
```

### ‚úÖ 3. Contr√¥le Qualit√© (Data Quality Check)

**Service** : `AIAgentService.check_data_quality()`

**V√©rifications** :
- Champs requis manquants
- Format email/t√©l√©phone invalide
- Adresses incompl√®tes
- Doublons internes
- Donn√©es incoh√©rentes (dates, montants)

**Score qualit√©** : 0-1 (seuil: 0.70)

**Exemple suggestion** :
```json
{
  "type": "data_quality",
  "entity_type": "person",
  "entity_id": 456,
  "title": "Probl√®me de qualit√© d√©tect√©",
  "description": "Email invalide d√©tect√©",
  "suggestion_data": {
    "field": "email",
    "current_value": "test@invalid",
    "issue": "domain_invalid",
    "suggested_value": null
  },
  "confidence_score": 1.0
}
```

### ‚úÖ 4. Cache Intelligent

**Table** : `ai_cache`

**Cl√© de cache** : Hash MD5 de `(request_type, request_data, ai_model)`

**Fonctionnement** :
1. Avant appel API IA ‚Üí V√©rifier cache
2. Si cache hit ‚Üí Incr√©menter `hit_count`, retourner r√©sultat
3. Si cache miss ‚Üí Appel API, stocker r√©sultat
4. Expiration : `expires_at` (ex: 7 jours)

**√âconomies** :
- Taux de cache actuel : **77%** (selon stats dashboard)
- Co√ªts API r√©duits de ~77%

### ‚úÖ 5. Budget Management

**Configuration** :
```python
daily_budget_usd: Float  # Budget quotidien max
monthly_budget_usd: Float  # Budget mensuel max
```

**Logique** (√† impl√©menter dans tests 17.13-17.14) :
- Avant chaque ex√©cution ‚Üí V√©rifier budget restant
- Si budget d√©pass√© ‚Üí Bloquer ex√©cution, notifier admin
- Calculer co√ªt estim√© : `(prompt_tokens + completion_tokens) * prix_token`

**Prix estim√©s** (Claude Sonnet 3.5) :
- Prompt : $3 / 1M tokens
- Completion : $15 / 1M tokens

### ‚úÖ 6. Auto-Application avec Seuil

**Configuration** :
```python
auto_apply_enabled: Boolean
auto_apply_confidence_threshold: Float (0.95)
```

**Fonctionnement** :
1. Si `auto_apply_enabled = True`
2. ET `confidence_score >= auto_apply_confidence_threshold`
3. ‚Üí Appliquer suggestion automatiquement
4. Cr√©er notification pour utilisateur
5. Marquer `auto_applied = True`, `status = applied`

---

## üìù Fichiers Cl√©s

### Backend
```
crm-backend/
‚îú‚îÄ‚îÄ models/ai_agent.py                    # 4 mod√®les DB (299 lignes)
‚îú‚îÄ‚îÄ services/ai_agent.py                  # Service principal (500+ lignes)
‚îú‚îÄ‚îÄ api/routes/ai_agent.py                # Routes API /ai/* (300+ lignes)
‚îú‚îÄ‚îÄ schemas/ai_agent.py                   # Sch√©mas Pydantic
‚îú‚îÄ‚îÄ tests/test_ai_agent.py                # Tests unitaires
‚îî‚îÄ‚îÄ alembic/versions/add_ai_agent_tables.py  # Migration DB
```

### Frontend
```
crm-frontend/
‚îú‚îÄ‚îÄ hooks/useAI.ts                        # React Query hooks (477 lignes)
‚îú‚îÄ‚îÄ types/ai.ts                           # Types TypeScript
‚îú‚îÄ‚îÄ app/dashboard/ai/
‚îÇ   ‚îú‚îÄ‚îÄ page.tsx                          # Dashboard principal
‚îÇ   ‚îú‚îÄ‚îÄ suggestions/page.tsx              # Liste suggestions
‚îÇ   ‚îî‚îÄ‚îÄ config/page.tsx                   # Configuration
‚îú‚îÄ‚îÄ components/ai/
‚îÇ   ‚îú‚îÄ‚îÄ AIStatCard.tsx                    # Carte KPI
‚îÇ   ‚îú‚îÄ‚îÄ AIExecutionsList.tsx              # Liste ex√©cutions
‚îÇ   ‚îú‚îÄ‚îÄ SuggestionsTable.tsx              # Table suggestions
‚îÇ   ‚îú‚îÄ‚îÄ SuggestionPreviewModal.tsx        # Preview
‚îÇ   ‚îî‚îÄ‚îÄ OrganisationAISuggestions.tsx     # Suggestions par org
‚îî‚îÄ‚îÄ __tests__/ai/
    ‚îú‚îÄ‚îÄ useAI.test.ts                     # Tests hooks
    ‚îî‚îÄ‚îÄ SuggestionsTable.test.tsx         # Tests composants
```

---

## üîß Tests Manuels √† Effectuer

### Test 17.1 - D√©tection de doublons ‚úÖ

**Proc√©dure** :
1. Cr√©er 2 organisations similaires :
   - Organisation A : "ACME Corporation", email: contact@acme.fr
   - Organisation B : "ACME Corp", email: contact@acme.fr
2. Aller sur `/dashboard/ai`
3. Cliquer sur "D√©tecter doublons"
4. V√©rifier :
   - [ ] T√¢che cr√©√©e (status 202)
   - [ ] Ex√©cution visible dans "Ex√©cutions r√©centes"
   - [ ] Suggestion cr√©√©e dans `/dashboard/ai/suggestions`
   - [ ] Confidence score ‚â• 0.85
   - [ ] Type = "duplicate_detection"

**R√©sultat attendu** :
```
‚úÖ Suggestion cr√©√©e
Type: Doublon potentiel
Entit√©: Organisation A (#123)
Confidence: 92%
Donn√©es: { duplicate_id: 124, similarity_score: 0.92 }
```

### Test 17.7 - Approuver suggestion ‚úÖ

**Proc√©dure** :
1. Aller sur `/dashboard/ai/suggestions?status=pending`
2. Cliquer sur "Approuver" sur une suggestion de doublon
3. V√©rifier :
   - [ ] Status passe √† "approved"
   - [ ] Organisations fusionn√©es (si doublon)
   - [ ] Notification succ√®s
   - [ ] Stats mises √† jour

### Test 17.13 - Budget quotidien ‚¨ú

**Proc√©dure** :
1. Aller sur `/dashboard/ai/config`
2. D√©finir `daily_budget_usd = 1.00` (1 dollar)
3. Lancer plusieurs t√¢ches jusqu'√† d√©passer le budget
4. V√©rifier :
   - [ ] Message erreur "Budget quotidien d√©pass√©"
   - [ ] T√¢che bloqu√©e
   - [ ] Notification admin

**Code √† tester** :
```python
# services/ai_agent.py
async def _check_budget(self) -> bool:
    """V√©rifie si le budget n'est pas d√©pass√©"""
    if not self.config.daily_budget_usd:
        return True

    today_cost = self.db.query(func.sum(AIExecution.estimated_cost_usd))\
        .filter(AIExecution.created_at >= datetime.now().replace(hour=0))\
        .scalar() or 0.0

    return today_cost < self.config.daily_budget_usd
```

### Test 17.14 - Auto-apply avec seuil ‚¨ú

**Proc√©dure** :
1. Aller sur `/dashboard/ai/config`
2. Activer `auto_apply_enabled = True`
3. D√©finir `auto_apply_confidence_threshold = 0.95`
4. Lancer d√©tection doublons
5. V√©rifier :
   - [ ] Suggestions avec confidence ‚â• 0.95 appliqu√©es automatiquement
   - [ ] `auto_applied = True`
   - [ ] `status = applied`
   - [ ] Notification envoy√©e

---

## üöÄ Autofill Pr√©dictif - Smart Fill (Nouveau)

### üéØ Objectif

**Remplir automatiquement les champs** √† partir de 2-3 infos (nom, soci√©t√©, domaine) :
- Email pro propos√© (pattern de l'entreprise)
- T√©l√©phone normalis√© E.164
- Pays/langue d√©duits
- Fonction probable

**UX** : Pills sous les inputs, validation Tab/Entr√©e. Pas de pluie de donn√©es.

---

### üß† Logique de D√©cision (Ordre de Priorit√©)

#### 1. R√®gles Locales (10-30ms) - Priorit√© 1
- **Pays via TLD** : `.fr` ‚Üí `FR`, `.de` ‚Üí `DE`, `.com` ‚Üí `US` (par d√©faut)
- **Langue** : `FR` ‚Üí `fr`, `DE` ‚Üí `de`, etc.
- **Normalisation t√©l√©phone** : E.164 (+33 pour FR)

#### 2. Inf√©rence Pattern Email (30-80ms) - Priorit√© 2
**√Ä partir des contacts existants du m√™me domaine** :

**Exemple** : Si tu as d√©j√† 3 contacts `@acme.com` :
- `jean.dupont@acme.com`
- `marie.bernard@acme.com`
- `paul.martin@acme.com`

‚Üí Pattern d√©tect√© : `prenom.nom@domain` (3/3 = 100% confidence)

**Patterns standards test√©s** :
```
{first}.{last}@{domain}      ‚Üí alice.durand@acme.com
{f}{last}@{domain}           ‚Üí adurand@acme.com
{first}{last}@{domain}       ‚Üí alicedurand@acme.com
{first}_{last}@{domain}      ‚Üí alice_durand@acme.com
{first}@{domain}             ‚Üí alice@acme.com
{last}@{domain}              ‚Üí durand@acme.com
```

**Score de confiance** :
- `0.90-1.0` : Pattern majoritaire (‚â•80% des contacts)
- `0.70-0.89` : Pattern fr√©quent (50-79%)
- `<0.70` : Incertain, proposer 2-3 candidats

#### 3. LLM "Gap Filler" (150-300ms) - Priorit√© 3 (Optionnel)
Si incertitude et budget disponible :
- Propose une valeur + justification
- Jamais d'auto-apply sur donn√©es sensibles (SIRET)

**Seuil d'auto-application** : `autofill_confidence_threshold = 0.85`

---

### üîå API Backend

#### Endpoint Unique

**POST /ai/autofill**

**Request** :
```json
{
  "entity_type": "person",
  "draft": {
    "first_name": "Alice",
    "last_name": "Durand",
    "organisation": "ACME",
    "domain": "acme.com",
    "country": null,
    "phone": "01 23 45 67 89",
    "email": null
  }
}
```

**Response** :
```json
{
  "suggestions": {
    "email": {
      "value": "alice.durand@acme.com",
      "confidence": 0.94,
      "source": "pattern_from_existing_contacts",
      "applied": true,
      "rationale": "3/3 contacts acme.com suivent prenom.nom",
      "alternatives": [
        "adurand@acme.com",
        "alice@acme.com"
      ]
    },
    "phone": {
      "value": "+33123456789",
      "confidence": 0.82,
      "source": "format_normalization",
      "applied": false,
      "rationale": "Num√©ro FR d√©tect√©, normalis√© E.164"
    },
    "country": {
      "value": "FR",
      "confidence": 0.90,
      "source": "tld_mapping",
      "applied": true,
      "rationale": "Domaine .com + t√©l√©phone FR ‚Üí pays FR"
    },
    "language": {
      "value": "fr",
      "confidence": 0.75,
      "source": "country_language_default",
      "applied": false,
      "rationale": "Langue par d√©faut pour pays FR"
    }
  },
  "meta": {
    "latency_ms": 145,
    "cache_hit": true,
    "rules_applied": 3,
    "llm_called": false
  }
}
```

**Champs retourn√©s** :
- `value` : Valeur sugg√©r√©e
- `confidence` : Score 0-1
- `source` : `pattern_from_contacts`, `tld_mapping`, `e164_normalization`, `llm_inference`
- `applied` : `true` si auto-appliqu√© (confidence ‚â• 0.85), `false` si propos√© en pill
- `rationale` : Explication courte
- `alternatives` : 1-2 autres candidats si applicable

---

### üíª Impl√©mentation Backend (Service)

**Fichier** : `services/autofill_service.py`

```python
"""
Service d'Autofill Pr√©dictif
Remplit automatiquement les champs √† partir de r√®gles + patterns existants
"""
from collections import Counter
import re
from typing import Dict, List, Optional, Tuple
from phonenumbers import parse as pn_parse, is_possible_number, format_number, PhoneNumberFormat
from sqlalchemy.orm import Session
from models.person import Person
from models.organisation import Organisation

# Mapping TLD ‚Üí Pays
TLD_TO_COUNTRY = {
    "fr": "FR", "de": "DE", "it": "IT", "es": "ES", "be": "BE",
    "ch": "CH", "lu": "LU", "nl": "NL", "uk": "GB", "co.uk": "GB",
    "com": None,  # Ind√©termin√©
}

# Mapping Pays ‚Üí Langue
COUNTRY_TO_LANGUAGE = {
    "FR": "fr", "DE": "de", "IT": "it", "ES": "es",
    "BE": "fr", "CH": "de", "LU": "fr", "NL": "nl", "GB": "en",
}

def slug(s: str) -> str:
    """Normalise une cha√Æne (minuscules, sans accents, sans espaces)"""
    return re.sub(r"[^a-z]", "", s.lower())

class AutofillService:
    """Service d'autofill pr√©dictif"""

    def __init__(self, db: Session):
        self.db = db
        self.confidence_threshold = 0.85  # Seuil auto-apply

    def autofill(self, entity_type: str, draft: Dict) -> Dict:
        """
        Autofill d'une entit√© (person ou organisation)

        Args:
            entity_type: "person" ou "organisation"
            draft: Donn√©es partielles

        Returns:
            { "suggestions": {...}, "meta": {...} }
        """
        suggestions = {}

        # 1. Email (si first_name, last_name, domain fournis)
        if entity_type == "person" and draft.get("first_name") and draft.get("last_name"):
            domain = draft.get("domain") or self._extract_domain(draft.get("organisation"))
            if domain:
                email_suggestion = self._infer_email(
                    draft["first_name"],
                    draft["last_name"],
                    domain
                )
                suggestions["email"] = email_suggestion

        # 2. T√©l√©phone (normalisation E.164)
        if draft.get("phone"):
            phone_suggestion = self._normalize_phone(
                draft["phone"],
                draft.get("country")
            )
            if phone_suggestion:
                suggestions["phone"] = phone_suggestion

        # 3. Pays (via TLD du domain)
        if not draft.get("country") and draft.get("domain"):
            country_suggestion = self._infer_country(draft["domain"])
            if country_suggestion:
                suggestions["country"] = country_suggestion

        # 4. Langue (via pays)
        if not draft.get("language"):
            country = draft.get("country") or suggestions.get("country", {}).get("value")
            if country:
                language_suggestion = self._infer_language(country)
                if language_suggestion:
                    suggestions["language"] = language_suggestion

        # Appliquer auto-apply selon seuil
        for field, suggestion in suggestions.items():
            suggestion["applied"] = suggestion["confidence"] >= self.confidence_threshold

        return {
            "suggestions": suggestions,
            "meta": {
                "latency_ms": 0,  # √Ä mesurer
                "cache_hit": False,
                "rules_applied": len(suggestions),
                "llm_called": False
            }
        }

    def _infer_email(self, first_name: str, last_name: str, domain: str) -> Dict:
        """Inf√®re l'email √† partir du pattern des contacts existants"""
        # Chercher contacts existants du m√™me domaine
        existing_emails = self.db.query(Person.email)\
            .filter(Person.email.like(f"%@{domain}"))\
            .limit(50)\
            .all()

        existing_emails = [e[0] for e in existing_emails if e[0]]

        # D√©tecter le pattern majoritaire
        if existing_emails:
            value, confidence, pattern_counts = self._detect_email_pattern(
                first_name, last_name, domain, existing_emails
            )

            # Alternatives (autres patterns fr√©quents)
            alternatives = self._generate_email_alternatives(
                first_name, last_name, domain, exclude=value
            )

            return {
                "value": value,
                "confidence": confidence,
                "source": "pattern_from_existing_contacts",
                "rationale": f"{len(existing_emails)} contact(s) {domain} analys√©(s)",
                "alternatives": alternatives[:2]
            }

        # Fallback : pattern standard (prenom.nom)
        f, l = slug(first_name), slug(last_name)
        value = f"{f}.{l}@{domain}"

        return {
            "value": value,
            "confidence": 0.65,  # Confiance moyenne (pas de donn√©es)
            "source": "default_pattern",
            "rationale": "Pattern standard prenom.nom (aucun contact trouv√©)",
            "alternatives": [
                f"{f[0]}{l}@{domain}",
                f"{f}{l}@{domain}"
            ]
        }

    def _detect_email_pattern(
        self,
        first: str,
        last: str,
        domain: str,
        existing: List[str]
    ) -> Tuple[str, float, Counter]:
        """D√©tecte le pattern majoritaire d'emails"""
        patterns = []
        f, l = slug(first), slug(last)

        for email in existing:
            local = email.split("@")[0].lower()

            # Identifier le pattern
            if local == f"{f}.{l}":
                patterns.append("first.last")
            elif local == f"{f}{l}":
                patterns.append("firstlast")
            elif local == f"{f}_{l}":
                patterns.append("first_last")
            elif local == f"{f[0]}{l}":
                patterns.append("f_last")
            elif local == f"{f}":
                patterns.append("first")
            elif local == f"{l}":
                patterns.append("last")

        if not patterns:
            # Aucun pattern identifi√© ‚Üí default
            return f"{f}.{l}@{domain}", 0.65, Counter()

        # Pattern majoritaire
        counts = Counter(patterns)
        best_pattern, count = counts.most_common(1)[0]
        confidence = count / len(patterns)

        # G√©n√©rer l'email selon le pattern
        pattern_to_email = {
            "first.last": f"{f}.{l}@{domain}",
            "firstlast": f"{f}{l}@{domain}",
            "first_last": f"{f}_{l}@{domain}",
            "f_last": f"{f[0]}{l}@{domain}",
            "first": f"{f}@{domain}",
            "last": f"{l}@{domain}",
        }

        value = pattern_to_email.get(best_pattern, f"{f}.{l}@{domain}")

        return value, confidence, counts

    def _generate_email_alternatives(
        self,
        first: str,
        last: str,
        domain: str,
        exclude: str = None
    ) -> List[str]:
        """G√©n√®re 2-3 alternatives d'email"""
        f, l = slug(first), slug(last)
        candidates = [
            f"{f}.{l}@{domain}",
            f"{f[0]}{l}@{domain}",
            f"{f}{l}@{domain}",
            f"{f}_{l}@{domain}",
        ]

        # Exclure la valeur principale
        if exclude:
            candidates = [c for c in candidates if c != exclude]

        return candidates[:2]

    def _normalize_phone(self, raw: str, country: str = None) -> Optional[Dict]:
        """Normalise un t√©l√©phone en E.164"""
        default_region = country or "FR"

        try:
            num = pn_parse(raw, default_region)
            if is_possible_number(num):
                value = format_number(num, PhoneNumberFormat.E164)

                return {
                    "value": value,
                    "confidence": 0.82,
                    "source": "e164_normalization",
                    "rationale": f"T√©l√©phone {default_region} normalis√© E.164",
                    "alternatives": []
                }
        except Exception:
            pass

        return None

    def _infer_country(self, domain: str) -> Optional[Dict]:
        """Inf√®re le pays √† partir du TLD"""
        tld = domain.split(".")[-1].lower()
        country = TLD_TO_COUNTRY.get(tld)

        if country:
            return {
                "value": country,
                "confidence": 0.90,
                "source": "tld_mapping",
                "rationale": f"TLD .{tld} ‚Üí Pays {country}",
                "alternatives": []
            }

        return None

    def _infer_language(self, country: str) -> Optional[Dict]:
        """Inf√®re la langue √† partir du pays"""
        language = COUNTRY_TO_LANGUAGE.get(country)

        if language:
            return {
                "value": language,
                "confidence": 0.75,
                "source": "country_language_default",
                "rationale": f"Langue par d√©faut pour {country}",
                "alternatives": []
            }

        return None

    def _extract_domain(self, organisation: str) -> Optional[str]:
        """Extrait le domain √† partir du nom d'organisation"""
        # Chercher l'organisation dans la DB
        if organisation:
            org = self.db.query(Organisation)\
                .filter(Organisation.name.ilike(f"%{organisation}%"))\
                .first()

            if org and org.website:
                # Extraire domain du website
                domain = org.website.replace("http://", "").replace("https://", "").split("/")[0]
                return domain

        return None
```

---

### üñ•Ô∏è Frontend - Hook + UI

#### Hook React Query

**Fichier** : `hooks/useAutofill.ts`

```typescript
import { useMutation } from '@tanstack/react-query'
import { apiClient } from '@/lib/api'

export interface AutofillRequest {
  entity_type: 'person' | 'organisation'
  draft: Record<string, any>
}

export interface AutofillSuggestion {
  value: any
  confidence: number
  source: string
  applied: boolean
  rationale: string
  alternatives?: any[]
}

export interface AutofillResponse {
  suggestions: Record<string, AutofillSuggestion>
  meta: {
    latency_ms: number
    cache_hit: boolean
    rules_applied: number
    llm_called: boolean
  }
}

export function useAutofill(entityType: 'person' | 'organisation') {
  return useMutation({
    mutationFn: async (draft: Record<string, any>): Promise<AutofillResponse> => {
      return apiClient.post<AutofillResponse>('/ai/autofill', {
        entity_type: entityType,
        draft,
      })
    },
  })
}
```

#### Int√©gration dans PersonForm

**Fichier** : `components/forms/PersonForm.tsx`

```typescript
import { useAutofill } from '@/hooks/useAutofill'
import { useState } from 'react'

export function PersonForm({ initialData, onSubmit }: PersonFormProps) {
  const form = useForm<PersonInput>({ defaultValues: initialData })
  const autofill = useAutofill('person')
  const [inlineSuggestions, setInlineSuggestions] = useState<Record<string, AutofillSuggestion>>({})

  // Fonction autofill
  const handleAutofill = () => {
    const draft = form.getValues()

    autofill.mutate(draft, {
      onSuccess: ({ suggestions }) => {
        const toApply: Record<string, any> = {}
        const toSuggest: Record<string, AutofillSuggestion> = {}

        for (const [field, suggestion] of Object.entries(suggestions)) {
          if (suggestion.applied) {
            // Auto-appliqu√© (confidence ‚â• 0.85)
            toApply[field] = suggestion.value
          } else {
            // Propos√© en pill
            toSuggest[field] = suggestion
          }
        }

        // Appliquer les champs auto-apply
        for (const [field, value] of Object.entries(toApply)) {
          form.setValue(field, value, { shouldDirty: true })
        }

        // Afficher pills pour les autres
        setInlineSuggestions(toSuggest)

        // Toast succ√®s
        showToast({
          type: 'success',
          title: 'Autofill appliqu√©',
          message: `${Object.keys(toApply).length} champ(s) rempli(s)`,
        })
      },
      onError: (error) => {
        showToast({
          type: 'error',
          title: 'Erreur autofill',
          message: error.message,
        })
      },
    })
  }

  // Accepter une suggestion inline
  const acceptSuggestion = (field: string) => {
    const suggestion = inlineSuggestions[field]
    if (suggestion) {
      form.setValue(field, suggestion.value, { shouldDirty: true })
      setInlineSuggestions(prev => {
        const next = { ...prev }
        delete next[field]
        return next
      })

      // Tracer l'acceptation
      trackAutofillAcceptance(field, suggestion)
    }
  }

  // Rejeter une suggestion
  const rejectSuggestion = (field: string) => {
    setInlineSuggestions(prev => {
      const next = { ...prev }
      delete next[field]
      return next
    })

    // Tracer le rejet
    trackAutofillRejection(field, inlineSuggestions[field])
  }

  return (
    <form onSubmit={form.handleSubmit(onSubmit)}>
      {/* Bouton Autofill */}
      <div className="mb-4">
        <button
          type="button"
          onClick={handleAutofill}
          disabled={autofill.isPending}
          className="px-4 py-2 bg-gradient-to-r from-purple-500 to-blue-500 text-white rounded-lg hover:opacity-90"
        >
          ‚ö° Remplir pour moi
        </button>
      </div>

      {/* Champs avec pills */}
      <div className="space-y-4">
        <div className="relative">
          <Input
            label="Email"
            {...form.register('email')}
            error={form.formState.errors.email?.message}
            onKeyDown={(e) => {
              if (e.key === 'Enter' && inlineSuggestions.email) {
                e.preventDefault()
                acceptSuggestion('email')
              } else if (e.key === 'Escape' && inlineSuggestions.email) {
                e.preventDefault()
                rejectSuggestion('email')
              }
            }}
          />
          {inlineSuggestions.email && (
            <SuggestionPill
              suggestion={inlineSuggestions.email}
              onAccept={() => acceptSuggestion('email')}
              onReject={() => rejectSuggestion('email')}
            />
          )}
        </div>

        <div className="relative">
          <Input
            label="T√©l√©phone"
            {...form.register('phone')}
            error={form.formState.errors.phone?.message}
            onKeyDown={(e) => {
              if (e.key === 'Enter' && inlineSuggestions.phone) {
                e.preventDefault()
                acceptSuggestion('phone')
              }
            }}
          />
          {inlineSuggestions.phone && (
            <SuggestionPill
              suggestion={inlineSuggestions.phone}
              onAccept={() => acceptSuggestion('phone')}
              onReject={() => rejectSuggestion('phone')}
            />
          )}
        </div>

        {/* Autres champs... */}
      </div>
    </form>
  )
}
```

#### Composant SuggestionPill

**Fichier** : `components/autofill/SuggestionPill.tsx`

```typescript
import { CheckIcon, XIcon, InfoIcon } from 'lucide-react'
import { AutofillSuggestion } from '@/hooks/useAutofill'

interface SuggestionPillProps {
  suggestion: AutofillSuggestion
  onAccept: () => void
  onReject: () => void
}

export function SuggestionPill({ suggestion, onAccept, onReject }: SuggestionPillProps) {
  return (
    <div className="mt-1 flex items-center gap-2 p-2 bg-blue-50 border border-blue-200 rounded-lg text-sm">
      <span className="flex-1 text-blue-900">
        <strong>{suggestion.value}</strong>
        <span className="text-blue-600 ml-2 text-xs">
          ({Math.round(suggestion.confidence * 100)}% confiance)
        </span>
      </span>

      {/* Tooltip rationale */}
      <div className="relative group">
        <InfoIcon className="h-4 w-4 text-blue-600 cursor-help" />
        <div className="absolute bottom-full mb-2 right-0 hidden group-hover:block bg-gray-900 text-white text-xs p-2 rounded shadow-lg w-48 z-10">
          {suggestion.rationale}
        </div>
      </div>

      {/* Actions */}
      <button
        type="button"
        onClick={onAccept}
        className="p-1 hover:bg-green-100 rounded"
        title="Accepter (Entr√©e)"
      >
        <CheckIcon className="h-4 w-4 text-green-600" />
      </button>

      <button
        type="button"
        onClick={onReject}
        className="p-1 hover:bg-red-100 rounded"
        title="Rejeter (√âchap)"
      >
        <XIcon className="h-4 w-4 text-red-600" />
      </button>
    </div>
  )
}
```

---

### üîê Garde-Fous & S√©curit√©

**R√®gles de s√©curit√©** :
1. ‚ùå **Jamais d'auto-apply** pour :
   - SIRET / num√©ro fiscal (sans source v√©rifi√©e)
   - Donn√©es financi√®res (montants, IBAN)
   - Donn√©es sensibles RGPD (origine ethnique, sant√©)

2. ‚úÖ **Tra√ßabilit√©** :
   - Journal `autofill_logs` : `who/when/field/value_before/value_after/source/accepted`
   - Permet d'auditer et d'am√©liorer les patterns

3. ‚úÖ **Mode d√©grad√©** :
   - Si budget IA atteint ‚Üí mode "r√®gles-only" (pas de LLM)
   - Si hors-ligne ‚Üí cache local + r√®gles simples

4. ‚úÖ **Respect CGU** :
   - On **n'extrait pas** de LinkedIn/Google
   - On **inf√®re** √† partir de donn√©es internes CRM uniquement

---

### ‚úÖ Checklist d'Activation

**Backend** :
- [ ] Cr√©er `services/autofill_service.py`
- [ ] Ajouter route `POST /ai/autofill`
- [ ] Cr√©er sch√©ma `AutofillRequest` / `AutofillResponse`
- [ ] Ajouter table `autofill_logs` pour tra√ßabilit√©
- [ ] Tests unitaires (patterns email, normalisation t√©l√©phone)

**Frontend** :
- [ ] Cr√©er hook `useAutofill()`
- [ ] Cr√©er composant `SuggestionPill`
- [ ] Brancher dans `PersonForm` + `OrganisationForm`
- [ ] Ajouter bouton "‚ö° Remplir pour moi"
- [ ] G√©rer raccourcis clavier (Tab/Enter, √âchap)

**Configuration** :
- [ ] Ajouter `autofill_confidence_threshold = 0.85` dans `AIConfiguration`
- [ ] Activer mode d√©grad√© si budget d√©pass√©
- [ ] Tracer acceptations/refus pour apprentissage

---

## üöÄ Roadmap Am√©liorations

### Phase 1 - Tests Manquants (P0)
1. **Test 17.13** : Valider budget quotidien/mensuel
2. **Test 17.14** : Valider auto-apply avec seuils
3. **Test 17.16-17.21** : Autofill pr√©dictif (6 tests)
4. **Test end-to-end** : Sc√©nario complet d√©tection ‚Üí preview ‚Üí approve

### Phase 2 - Autofill Avanc√© (P1)
1. **Fonction/Seniority** :
   - D√©duire fonction √† partir des interactions (emails, titres)
   - D√©tecter seniority (Junior, Senior, Manager, C-level)
2. **Enrichissement externe** :
   - Int√©gration API (Clearbit, Hunter.io, Dropcontact)
   - V√©rification emails (deliverability)
3. **Apprentissage patterns** :
   - ML pour d√©tecter patterns complexes
   - Am√©lioration continue via feedback utilisateur

### Phase 3 - G√©n√©ration de Contenu (P2)
1. **G√©n√©ration emails marketing** :
   - G√©n√©rer contenu avec IA
   - R√©sum√©s automatiques d'interactions
   - Templates personnalis√©s
2. **Analytics pr√©dictives** :
   - Lead scoring IA
   - Pr√©diction churn
   - Recommandations actions
3. **Recherche s√©mantique** :
   - Recherche par intention
   - Similarit√© documents
   - Clustering contacts

### Phase 4 - Optimisations (P3)
1. **Performance** :
   - Streaming responses (SSE)
   - Parall√©lisation t√¢ches IA
   - Batch processing optimis√©
2. **Monitoring** :
   - Dashboard m√©triques temps r√©el
   - Alertes budgets
   - Logs d√©taill√©s
3. **Int√©grations** :
   - Webhooks pour suggestions
   - Export suggestions CSV
   - API publique AI

---

## üìä Comparaison Providers IA

| Feature | Claude (Anthropic) | OpenAI | Ollama |
|---------|-------------------|--------|--------|
| **Co√ªt** | $3-15 / 1M tokens | $0.50-60 / 1M tokens | Gratuit (local) |
| **Latence** | ~2-5s | ~1-3s | Variable (CPU/GPU) |
| **Qualit√©** | Excellente | Excellente | Bonne |
| **Context** | 200k tokens | 128k tokens | Variable (mod√®le) |
| **Privacy** | Cloud | Cloud | Local ‚úÖ |
| **Support** | ‚úÖ | ‚úÖ | ‚úÖ |

**Recommandation actuelle** : **Claude 3.5 Sonnet** (qualit√© + context window)

---

## ‚úÖ Conclusion

### Score Global : **85/100** (Tr√®s bon)

**Points forts** :
‚úÖ Architecture compl√®te (4 mod√®les DB, service, routes, frontend)
‚úÖ Multi-providers (Claude, OpenAI, Ollama)
‚úÖ Cache intelligent (77% hit rate, √©conomies ~77%)
‚úÖ Batch operations (approve/reject en masse)
‚úÖ Dashboard statistiques temps r√©el
‚úÖ Tests unitaires backend (test_ai_agent.py)
‚úÖ Hooks React Query bien structur√©s
‚úÖ Configuration flexible (seuils, budgets, auto-apply)

**Points √† am√©liorer** :
‚¨ú Tests manuels 17.13-17.14 (budgets, auto-apply)
‚¨ú **Autofill pr√©dictif (17.16-17.21)** - Sp√©cification compl√®te, √† impl√©menter
‚¨ú G√©n√©ration de contenu (emails, r√©sum√©s)
‚¨ú Analytics pr√©dictives (lead scoring, churn)
‚¨ú Streaming responses (SSE)
‚¨ú Documentation utilisateur (guides)

**Recommandation** :
- L'agent IA est **production-ready** pour les fonctionnalit√©s impl√©ment√©es (d√©tection doublons, enrichissement, qualit√©)
- **Autofill pr√©dictif** : Sp√©cification compl√®te disponible avec code backend/frontend pr√™t √† brancher (section ci-dessus)
- Les tests de budget et auto-apply doivent √™tre valid√©s avant activation en production

---

## üéØ System Prompt Production - Autofill + T√¢ches IA

### üìå Vue d'ensemble

Ce prompt syst√®me permet √† l'agent IA de :
1. **Remplir automatiquement** les champs (autofill pr√©dictif) √† partir de signaux multi-sources
2. **G√©n√©rer des t√¢ches** intelligentes (Next Best Actions) dat√©es et actionnables
3. **Respecter les budgets** et garde-fous (pas d'invention de donn√©es critiques)

**Sources de donn√©es** :
- üè¢ **Base interne** : Patterns email existants, contacts confirm√©s
- üìß **Outlook** : Signatures emails, threads sans r√©ponse
- üíº **LinkedIn** : Pages consult√©es, headlines
- üîç **Google** : News r√©centes, PDFs trouv√©s

**Seuils** :
- `auto_apply` si `confidence ‚â• 0.85` et source fiable
- Pattern email : auto si confirm√© par ‚â•2 contacts du domaine
- T√©l√©phone : normalisation E.164 auto si plausible

---

### ü§ñ Prompt Syst√®me (3 blocs)

#### Bloc 1 : System

```
Tu es un agent IA de productivit√© pour un CRM B2B (Alforis).
Objectif prioritaire:
1) Proposer un remplissage automatique minimal mais utile des champs (autofill pr√©dictif) √† partir de signaux Outlook, LinkedIn, Google et de la base locale.
2) G√©n√©rer des "Next Best Actions" (t√¢ches) concr√®tes, dat√©es, non bavardes, pr√™tes √† ex√©cuter.

Contraintes:
- Jamais d'invention de donn√©es critiques (SIRET, num√©ro fiscal). Si source incertaine: proposer sans auto-appliquer.
- Pr√©f√©rence aux sources internes r√©centes, ensuite Outlook signatures, ensuite r√®gles simples, ensuite embeddings DB, ensuite LLM.
- Respecter le budget token; si budget serr√©: passer en mode "rules+embeddings-only".
- R√©ponses strictement en JSON valide; ne jamais ajouter de prose hors JSON.
- Latence cible: p95 < 3s. R√©duire la longueur des sorties.
- Champs minimalistes: seulement ce qui fait gagner des clics maintenant.

Seuils & politiques:
- auto_apply si confidence ‚â• 0.85 et source ‚àà {internal_db, outlook_signature, phone_normalization}
- pour email par pattern: auto_apply si pattern confirm√© par ‚â• 2 correspondants du m√™me domaine
- pour t√©l√©phone: normaliser E.164; auto_apply si num√©ro plausible pour le pays inf√©r√©
- toute suggestion inclut {value, confidence, source, rationale_short}

Sorties:
- autofill: suggestions par champ
- tasks: liste de t√¢ches "faibles frictions" avec due_date, assignee, tags, links_to_context
```

#### Bloc 2 : Developer

```
Donn√©es disponibles (exemples):
- draft: objet partiel de l'entit√© (person ou organisation)
- internal_db: contacts et domaines d√©j√† connus (emails confirm√©s, patterns majoritaires)
- outlook: derniers messages + signatures (email, phone, job_title, company, address)
- linkedin_meta: page consult√©e r√©cemment (person, headline, company)
- google_signals: news r√©centes sur l'entreprise, PDFs trouv√©s
- policy: {autofill_confidence_threshold: 0.85, budgets, locales}

R√®gles de d√©cision:
1) Pays et langue: tld domaine, signature Outlook, locale utilisateur.
2) Email:
   a) si outlook_signature.email ‚Üí propose avec confidence 0.95
   b) sinon si pattern_domaine confirm√© (‚â•2) ‚Üí propose email pattern avec confidence 0.9
   c) sinon fournir 1‚Äì2 candidats sans auto_apply
3) T√©l√©phone:
   a) si signature Outlook ‚Üí normaliser E.164, auto_apply si plausible pour pays
   b) sinon aucune invention
4) T√¢ches:
   a) mail sans r√©ponse > X jours ‚Üí "Relancer"
   b) news positive ‚Üí "F√©liciter / proposer point"
   c) visite LinkedIn r√©cente + pas d'interaction ‚Üí "Message d'intro"
   d) fiche incompl√®te ‚Üí "Compl√©ter contact"
   G√©n√©rer 1 √† 3 t√¢ches max, jamais plus.

Format attendu (JSON strict):
{
  "autofill": {
    "email": {"value":"", "confidence":0.0, "source":"", "applied":false, "rationale_short":""},
    "phone": {"value":"", "confidence":0.0, "source":"", "applied":false, "rationale_short":""},
    "country": {...},
    "language": {...},
    "job_title": {...}
  },
  "tasks":[
    {
      "title":"Relancer Alice au sujet de l'offre",
      "due_date":"2025-11-03",
      "assignee":"current_user",
      "confidence":0.9,
      "reason":"outlook_no_reply_7d",
      "context_links":["outlook:messageId=..."],
      "tags":["followup","outlook"],
      "estimated_minutes":5
    }
  ],
  "meta":{"mode":"rules|embeddings|llm|hybrid","cache_hit":true,"model":"claude-3-5-sonnet-20241022"}
}
```

#### Bloc 3 : User (Template)

```
Contexte utilisateur:
- entity_type: "person" | "organisation"
- draft: {...}   // valeurs saisies partielles
- internal_db: { known_domain_patterns: {...}, last_contacts: [...] }
- outlook: { recent_signatures: [...], unanswered_threads: [...] }
- linkedin_meta: { person: {...}, company: {...} }
- google_signals: { news_headlines: [...], pdf_titles: [...] }
- policy: { autofill_confidence_threshold: 0.85, locale: "fr-FR", budget_mode: "normal"|"low" }

T√¢che:
1) G√©n√®re un JSON strict conforme au sch√©ma Developer.
2) Propose au maximum 5 champs d'autofill. N'invente pas.
3) Propose 1‚Äì3 t√¢ches max, ou 0 si rien de net.
```

---

### üìö Few-Shot Examples

#### Exemple A - Email via pattern confirm√©

**Input** :
```json
{
  "draft": {"first_name":"Alice", "last_name":"Durand", "domain":"acme.com"},
  "internal_db": {
    "known_domain_patterns": {
      "acme.com": {"first.last": 3, "f.last": 1}
    }
  }
}
```

**Output** :
```json
{
  "autofill": {
    "email": {
      "value": "alice.durand@acme.com",
      "confidence": 0.9,
      "source": "domain_pattern",
      "applied": true,
      "rationale_short": "pattern majoritaire 3/4"
    }
  },
  "tasks": [],
  "meta": {"mode": "rules", "cache_hit": true, "model": "claude-3-5-sonnet-20241022"}
}
```

---

#### Exemple B - T√©l√©phone sign√© Outlook

**Input** :
```json
{
  "outlook": {
    "recent_signatures": [
      "Alice Durand ‚Äî Head of Sales\nTel: +33 1 84 20 12 34"
    ]
  }
}
```

**Output** :
```json
{
  "autofill": {
    "phone": {
      "value": "+33184201234",
      "confidence": 0.88,
      "source": "outlook_signature",
      "applied": true,
      "rationale_short": "signature r√©cente normalis√©e E.164"
    }
  },
  "tasks": [],
  "meta": {"mode": "rules", "cache_hit": false, "model": "claude-3-5-sonnet-20241022"}
}
```

---

#### Exemple C - Mail sans r√©ponse

**Input** :
```json
{
  "outlook": {
    "unanswered_threads": [
      {"thread_id": "abc", "subject": "Offre commerciale", "older_than_days": 7}
    ]
  }
}
```

**Output** :
```json
{
  "autofill": {},
  "tasks": [
    {
      "title": "Relancer Alice sur l'offre",
      "due_date": "2025-11-03",
      "assignee": "current_user",
      "confidence": 0.9,
      "reason": "outlook_no_reply_7d",
      "context_links": ["outlook:thread=abc"],
      "tags": ["followup", "outlook"],
      "estimated_minutes": 5
    }
  ],
  "meta": {"mode": "rules", "cache_hit": true, "model": "claude-3-5-sonnet-20241022"}
}
```

---

## üöÄ Plan V2 - Int√©grations Cross-Sources

### üéØ Objectif V2

Livrer un **autofill pr√©dictif + cr√©ation de t√¢ches** multi-sources qui fonctionne au quotidien, sans surcharge de travail.

**Timeline** : 8-13 jours (3 phases)

---

### Phase 1 - Fondations (3-5 jours)

#### 1.1 Outlook Read-Only Minimal

**Objectif** : Ing√©rer signatures emails + threads sans r√©ponse

**Impl√©mentation** :
- OAuth Microsoft Graph (scopes : `Mail.Read`, `Contacts.Read`)
- Stocker refresh token chiffr√© dans `users.encrypted_outlook_token`
- Ingestion "delta" : 50 derniers mails + contacts modifi√©s

**Endpoints** :
```
POST /integrations/outlook/authorize
GET /integrations/outlook/sync
GET /integrations/outlook/signatures
```

**Parser signatures** :
```python
def parse_signature(html: str) -> Dict:
    """
    Extrait email, phone, job_title, company, address
    Exemples:
    - "Alice Durand ‚Äî Head of Sales | Tel: +33 1 84 20 12 34"
    - "alice.durand@acme.com | ACME Corp"
    """
    # Regex patterns pour email, t√©l√©phone, fonction
    email_pattern = r'[a-z0-9._%+-]+@[a-z0-9.-]+\.[a-z]{2,}'
    phone_pattern = r'\+?[0-9][\s\-\.\(\)0-9]{7,18}'

    return {
        "email": extract_email(html),
        "phone": extract_phone(html),
        "job_title": extract_job_title(html),
        "company": extract_company(html)
    }
```

**Threads sans r√©ponse** :
```python
def detect_unanswered_threads(user_id: int) -> List[Dict]:
    """
    Threads envoy√©s sans r√©ponse depuis > 3/7 jours
    """
    return [
        {
            "thread_id": "abc",
            "subject": "Offre commerciale",
            "recipient": "alice@acme.com",
            "sent_date": "2025-10-20",
            "older_than_days": 7
        }
    ]
```

---

#### 1.2 Autofill Endpoint V2

**Endpoint** : `POST /ai/autofill/v2`

**Pipeline de d√©cision** :
```
1. Rules (10ms)        ‚Üí Pays/langue via TLD, normalisation t√©l√©phone
2. DB Patterns (20ms)  ‚Üí Patterns email confirm√©s (‚â•2 contacts)
3. Outlook (50ms)      ‚Üí Signatures r√©centes
4. LLM Fallback (300ms)‚Üí Si incertitude ET budget disponible
```

**Request** :
```json
{
  "entity_type": "person",
  "draft": {
    "first_name": "Alice",
    "last_name": "Durand",
    "domain": "acme.com"
  },
  "context": {
    "outlook_enabled": true,
    "linkedin_enabled": false,
    "budget_mode": "normal"
  }
}
```

**Response** :
```json
{
  "autofill": {
    "email": {
      "value": "alice.durand@acme.com",
      "confidence": 0.95,
      "source": "outlook_signature",
      "applied": true,
      "rationale_short": "signature mail du 25/10",
      "evidence_hash": "sha256:abc123..."
    },
    "phone": {
      "value": "+33184201234",
      "confidence": 0.88,
      "source": "outlook_signature",
      "applied": true,
      "rationale_short": "normalis√© E.164"
    }
  },
  "tasks": [
    {
      "title": "Relancer Alice sur l'offre commerciale",
      "due_date": "2025-11-03",
      "assignee": "current_user",
      "confidence": 0.9,
      "reason": "outlook_no_reply_7d",
      "context_links": ["outlook:thread=abc"],
      "tags": ["followup", "outlook"],
      "estimated_minutes": 5
    }
  ],
  "meta": {
    "mode": "rules+outlook",
    "cache_hit": false,
    "latency_ms": 145,
    "llm_called": false,
    "model": null
  }
}
```

---

#### 1.3 UI Pills + Raccourcis

**Bouton principal** :
```tsx
<button onClick={handleAutofill} className="...">
  ‚ö° Remplir pour moi
</button>
```

**Raccourcis clavier** :
- `Enter` : Accepter suggestion actuelle
- `Esc` : Ignorer suggestion actuelle
- `Cmd+K` / `Ctrl+K` : Accepter toutes les suggestions ‚â• seuil (0.85)
- `Cmd+Shift+K` : Tout ignorer

**Pills am√©lior√©es** :
```tsx
<SuggestionPill
  suggestion={suggestion}
  onAccept={() => acceptSuggestion(field)}
  onReject={() => rejectSuggestion(field)}
  evidencePreview={suggestion.evidence_hash} // Hover ‚Üí extrait signature
/>
```

---

#### 1.4 T√¢ches Outlook No-Reply

**Service** : `services/task_automation.py`

```python
def generate_outlook_followup_tasks(user_id: int) -> List[Task]:
    """
    G√©n√®re t√¢ches de relance pour threads sans r√©ponse

    R√®gles:
    - J+3 : Relance "douce"
    - J+7 : Relance "urgente"
    - J+14 : Archiver / classer perdu
    """
    unanswered = detect_unanswered_threads(user_id)

    tasks = []
    for thread in unanswered:
        if thread["older_than_days"] >= 7:
            priority = "high"
            title = f"Relancer {thread['recipient']} (urgent)"
        elif thread["older_than_days"] >= 3:
            priority = "medium"
            title = f"Relancer {thread['recipient']}"
        else:
            continue  # Pas encore de t√¢che

        tasks.append({
            "title": title,
            "due_date": today + timedelta(days=1),
            "priority": priority,
            "source": "outlook_no_reply",
            "context": thread
        })

    return tasks[:3]  # Max 3 t√¢ches/jour
```

**Notification quotidienne** :
- Cron : 9h du matin
- Email digest : "Vous avez 3 relances √† faire aujourd'hui"
- Badge dans navbar : `<NotificationBell count={3} />`

---

#### üìä KPIs Phase 1

| M√©trique | Cible | Mesure |
|----------|-------|--------|
| Email auto-rempli | ‚â•70% fiches | % fiches avec email auto-appliqu√© |
| T√©l√©phone normalis√© | ‚â•60% | % t√©l√©phones E.164 issus Outlook |
| Clics moyens / contact | ‚â§2 | Mesure UX (clicks to complete) |
| Latence p95 | <3s | Temps r√©ponse /ai/autofill/v2 |
| T√¢ches g√©n√©r√©es/jour | 1-3 | Nombre t√¢ches Outlook no-reply |

---

### Phase 2 - LinkedIn + Google (3-5 jours)

#### 2.1 LinkedIn Meta Light (Capture Volontaire)

**Objectif** : Capturer URL + headline quand tu visites une page LinkedIn

**Extension navigateur** (optionnel) ou **capture manuelle** :
```tsx
// Dans PersonForm
<Input
  label="LinkedIn URL"
  {...register('linkedin_url')}
  onBlur={(e) => {
    if (e.target.value.includes('linkedin.com/in/')) {
      fetchLinkedInMeta(e.target.value)
    }
  }}
/>
```

**Parser LinkedIn URL** :
```python
def parse_linkedin_url(url: str) -> Dict:
    """
    Extrait headline, company depuis meta tags publics
    (pas de scraping, juste OG tags)
    """
    html = fetch_public_meta(url)  # Respecte robots.txt

    return {
        "headline": extract_meta_tag(html, "og:description"),
        "company": extract_company_from_headline(headline),
        "profile_url": url
    }
```

**G√©n√©ration de t√¢ches** :
```python
if linkedin_meta and not has_recent_interaction(person_id):
    tasks.append({
        "title": f"Envoyer message d'intro √† {person.name}",
        "due_date": today + timedelta(days=1),
        "reason": "linkedin_visit_no_interaction",
        "context_links": [linkedin_meta["profile_url"]],
        "tags": ["linkedin", "outreach"],
        "estimated_minutes": 10
    })
```

---

#### 2.2 Google Signals Light

**Objectif** : D√©tecter news positives + PDFs utiles

**Google News API** (ou RSS feeds) :
```python
def fetch_company_news(company_name: str, days: int = 7) -> List[Dict]:
    """
    News r√©centes sur l'entreprise (API News ou RSS)
    """
    query = f'"{company_name}" (financement OR acquisition OR croissance OR partenariat)'

    return [
        {
            "title": "ACME Corp l√®ve 10M‚Ç¨",
            "url": "https://...",
            "published_date": "2025-10-25",
            "sentiment": "positive"
        }
    ]
```

**G√©n√©ration de t√¢ches** :
```python
if news and news["sentiment"] == "positive":
    tasks.append({
        "title": f"F√©liciter {contact.name} pour la lev√©e de fonds",
        "due_date": today + timedelta(days=1),
        "reason": "google_positive_news",
        "context_links": [news["url"]],
        "tags": ["news", "congratulate"],
        "estimated_minutes": 5
    })
```

**Google Custom Search (PDFs)** :
```python
def find_company_pdfs(company_name: str) -> List[Dict]:
    """
    Recherche filetype:pdf pour trouver docs publics
    """
    query = f'{company_name} filetype:pdf (rapport OR plaquette OR pr√©sentation)'

    return [
        {
            "title": "Rapport annuel 2024",
            "url": "https://acme.com/rapport2024.pdf",
            "size_kb": 1250
        }
    ]
```

---

#### 2.3 NBA Engine (Next Best Actions)

**R√®gles d√©terministes** :

| Condition | T√¢che G√©n√©r√©e | Priorit√© |
|-----------|---------------|----------|
| Dernier contact > 21 jours | "Proposer call 30 min" | Moyenne |
| Deal stade="proposal" | "Relancer d√©cision" J+3 | Haute |
| Fiche incompl√®te (score <50%) | "Compl√©ter contact" | Basse |
| News positive | "F√©liciter + proposer point" | Moyenne |
| Visite LinkedIn + pas d'interaction | "Message d'intro" | Basse |

**Impl√©mentation** :
```python
class NBAEngine:
    """Next Best Actions Engine - R√®gles d√©terministes"""

    def __init__(self, db: Session):
        self.db = db

    def generate_nba(self, person_id: int) -> List[Task]:
        """G√©n√®re 1-3 t√¢ches max par contact"""
        person = self.db.query(Person).get(person_id)
        tasks = []

        # R√®gle 1: Dernier contact > 21j
        if days_since_last_contact(person) > 21:
            tasks.append({
                "title": f"Proposer call 30min avec {person.name}",
                "due_date": today + timedelta(days=3),
                "priority": "medium",
                "reason": "no_contact_21d",
                "estimated_minutes": 30
            })

        # R√®gle 2: Deal en attente
        if person.active_deal and person.active_deal.stage == "proposal":
            tasks.append({
                "title": f"Relancer d√©cision deal {person.active_deal.name}",
                "due_date": today + timedelta(days=3),
                "priority": "high",
                "reason": "deal_proposal_pending",
                "estimated_minutes": 15
            })

        # R√®gle 3: Fiche incompl√®te
        completeness = calculate_completeness(person)
        if completeness < 0.5:
            tasks.append({
                "title": f"Compl√©ter fiche {person.name}",
                "due_date": today + timedelta(days=7),
                "priority": "low",
                "reason": "profile_incomplete",
                "estimated_minutes": 5
            })

        return tasks[:3]  # Cap 3 t√¢ches max
```

---

#### üìä KPIs Phase 2

| M√©trique | Cible | Mesure |
|----------|-------|--------|
| T√¢ches g√©n√©r√©es/jour | 1-3 | Moyenne par utilisateur actif |
| Taux d'ex√©cution t√¢ches IA | >50% | % t√¢ches compl√©t√©es sous 7j |
| Taux de rejet | <20% | % t√¢ches archiv√©es sans action |
| Satisfaction utilisateur | >4/5 | Survey mensuel "T√¢ches IA utiles?" |

---

### Phase 3 - Durcissement (2-3 jours)

#### 3.1 Budgets & Modes D√©grad√©s

**Configuration** :
```python
class AIConfiguration:
    daily_budget_usd: Float = 5.0
    monthly_budget_usd: Float = 100.0
    budget_mode: Enum = ["normal", "low", "emergency"]
```

**Logique de basculement** :
```python
def get_budget_mode(config: AIConfiguration) -> str:
    """D√©termine le mode selon budget consomm√©"""
    today_cost = calculate_today_cost()
    month_cost = calculate_month_cost()

    if month_cost >= config.monthly_budget_usd * 0.9:
        return "emergency"  # Rules only
    elif today_cost >= config.daily_budget_usd * 0.8:
        return "low"  # Rules + DB + Outlook only
    else:
        return "normal"  # Full stack
```

**Modes disponibles** :

| Mode | Sources | LLM | Latence |
|------|---------|-----|---------|
| **Normal** | Rules + DB + Outlook + LinkedIn + Google + LLM | Oui | ~300ms |
| **Low** | Rules + DB + Outlook | Non | ~50ms |
| **Emergency** | Rules only | Non | ~10ms |

---

#### 3.2 Cache & Fra√Æcheur

**TTL par type** :
```python
CACHE_TTL = {
    "domain_pattern": 7 * 24 * 3600,      # 7 jours
    "outlook_signature": 3 * 24 * 3600,   # 3 jours
    "linkedin_meta": 30 * 24 * 3600,      # 30 jours
    "google_news": 1 * 24 * 3600,         # 1 jour
}
```

**Invalidation** :
```python
def invalidate_cache_on_new_evidence(person_id: int, field: str):
    """Invalide cache si nouvelle signature Outlook d√©tect√©e"""
    if field == "email" and source == "outlook_signature":
        redis.delete(f"autofill:email:{person_id}")
```

---

#### 3.3 Audit & RGPD

**Table** : `autofill_logs`

```sql
CREATE TABLE autofill_logs (
    id SERIAL PRIMARY KEY,
    user_id INTEGER NOT NULL,
    entity_type VARCHAR(50),
    entity_id INTEGER,
    field VARCHAR(100),
    value_before TEXT,
    value_after TEXT,
    source VARCHAR(100),
    confidence FLOAT,
    evidence_hash VARCHAR(64),  -- SHA256 du contenu source
    accepted BOOLEAN,
    created_at TIMESTAMP DEFAULT NOW()
);
```

**RGPD - Droit √† l'oubli** :
```python
def forget_contact(person_id: int):
    """Efface toutes les traces d'ingestion"""
    # Supprimer logs autofill
    db.query(AutofillLog).filter(entity_id=person_id).delete()

    # Supprimer cache
    redis.delete(f"autofill:*:{person_id}")

    # Supprimer meta Outlook/LinkedIn
    db.query(OutlookSignature).filter(person_id=person_id).delete()
    db.query(LinkedInMeta).filter(person_id=person_id).delete()
```

---

#### üìä KPIs Phase 3

| M√©trique | Cible | Mesure |
|----------|-------|--------|
| Latence p95 | <2.5s | Temps r√©ponse /ai/autofill/v2 |
| Suggestions valid√©es | ‚â•75% | % accept√©es sans modification |
| Budget mensuel | <100$ | Co√ªt total API LLM |
| Cache hit rate | >60% | % requ√™tes servies par cache |

---

## üß™ Nouveaux Tests (17.22-17.30)

### Int√©grations Outlook (3 tests)

| # | Test | Statut | Remarques |
|---|------|--------|-----------|
| 17.22 | **Test** : Ingestion signatures Outlook | ‚¨ú | OAuth + parser signatures |
| 17.23 | **Test** : D√©tection threads sans r√©ponse J+7 | ‚¨ú | G√©n√©ration t√¢che "Relancer" |
| 17.24 | **Test** : Autofill email depuis signature | ‚¨ú | Confidence 0.95, auto-apply |

### Int√©grations LinkedIn (2 tests)

| # | Test | Statut | Remarques |
|---|------|--------|-----------|
| 17.25 | **Test** : Capture URL + headline LinkedIn | ‚¨ú | Meta OG tags publics |
| 17.26 | **Test** : T√¢che "Message intro" si pas d'interaction | ‚¨ú | G√©n√©ration NBA |

### Int√©grations Google (2 tests)

| # | Test | Statut | Remarques |
|---|------|--------|-----------|
| 17.27 | **Test** : News positives ‚Üí t√¢che "F√©liciter" | ‚¨ú | Google News API |
| 17.28 | **Test** : PDFs trouv√©s ‚Üí t√¢che "Ajouter au dossier" | ‚¨ú | Custom Search filetype:pdf |

### NBA Engine (2 tests)

| # | Test | Statut | Remarques |
|---|------|--------|-----------|
| 17.29 | **Test** : Dernier contact >21j ‚Üí "Proposer call" | ‚¨ú | R√®gle d√©terministe |
| 17.30 | **Test** : Cap 3 t√¢ches/jour par compte | ‚¨ú | Cool-down period |

---

## üì¶ Livrables Concrets

### Backend ‚úÖ Phase 1 Termin√©e
- [x] `services/autofill_service_v2.py` - Pipeline multi-sources (~300 lignes)
- [x] `services/outlook_integration.py` - OAuth + parser signatures (~200 lignes)
- [ ] `services/linkedin_integration.py` - Meta capture (Phase 2)
- [ ] `services/google_integration.py` - News + PDFs (Phase 2)
- [ ] `services/nba_engine.py` - Next Best Actions (Phase 3)
- [x] Routes `/integrations/outlook/*`, `/ai/autofill/v2` - API compl√®te
- [x] User model: Outlook OAuth fields (migration appliqu√©e)
- [x] Schemas Pydantic: `schemas/integrations.py` (~180 lignes)
- [x] Encryption helpers: `encrypt_value()`, `decrypt_value()`
- [ ] Table `autofill_logs`, `outlook_signatures` (Phase 1.5 - optionnel)

### Frontend ‚úÖ Phase 1 Termin√©e
- [x] `hooks/useAutofillV2.ts` - Hook multi-sources avec React Query
- [x] `components/autofill/SuggestionPill.tsx` - Pills avec evidence + tooltip
- [x] Int√©gration PersonForm - Autofill sur blur email
- [x] Suggestions visuelles pour: email, phone, country, language
- [ ] `components/tasks/AITasksList.tsx` - Liste t√¢ches g√©n√©r√©es (Phase 2)
- [ ] `components/tasks/TaskBanner.tsx` - Banner "T√¢ches du jour" (Phase 2)
- [ ] Bouton "‚ö° Remplir pour moi" global (Phase 1.5 - optionnel)
- [x] Raccourcis clavier (Cmd+Enter accepte, Esc rejette)

### Refactoring UX
- [x] **Centraliser toutes les int√©grations** sur `/dashboard/settings/integrations` ‚úÖ **COMPL√âT√â**
  - ‚úÖ Config IA d√©plac√©e depuis `/dashboard/ai/config`
  - ‚úÖ Layout avec onglets : "Email", "Webhooks", "Intelligence Artificielle", "Connecteurs"
  - ‚úÖ Ancienne route `/dashboard/ai/config` redirige automatiquement
  - ‚úÖ Benefits : Une seule page pour toutes les connexions externes (Email, IA, Webhooks, Zapier/Make)
  - ‚è∏Ô∏è Sections Outlook, LinkedIn, Google √† ajouter en Phase 2 (Autofill V2)

### Tests
- [ ] Tests 17.22-17.30 (9 nouveaux tests)
- [ ] Tests unitaires parsers (signatures, LinkedIn, news)
- [ ] Tests E2E autofill complet

### Documentation
- [ ] `docs/ai/AUTOFILL_V2.md` - Guide utilisateur
- [ ] `docs/ai/SOURCES_MAPPING.md` - Mapping sources ‚Üí champs
- [ ] `docs/ai/NBA_RULES.md` - R√®gles Next Best Actions

---

## ‚ö†Ô∏è Risques & Parades

| Risque | Impact | Parade |
|--------|--------|--------|
| **Invention donn√©es sensibles** | Critique | Politiques strictes : jamais auto pour SIRET/fiscal |
| **Spam de t√¢ches** | Moyen | Cap 3 t√¢ches/jour, cool-down, bouton "Pause IA" |
| **Latence > 3s** | Moyen | Cache agressif, LLM en dernier recours |
| **Budget d√©pass√©** | Faible | Mode d√©grad√© automatique, alertes √† 80% |
| **RGPD non-respect** | Critique | Droit √† l'oubli, logs tra√ßables, consentement |
| **Rate limiting API** | Faible | Exponential backoff, retry logic |

---

**Derni√®re mise √† jour :** 27 Octobre 2025
**Code Review By :** Claude Code
**Status :** ‚úÖ **V2 SPEC READY** (57%) - 12/30 tests - Architecture V1 + V2 compl√®te + System Prompt production
