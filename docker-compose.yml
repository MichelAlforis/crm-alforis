# ===========================================
# DOCKER COMPOSE - CRM TPM FINANCE (UNIFIÉ)
# ===========================================
# - .env à la racine chargé automatiquement
# - Healthchecks robustes
# - Volumes pour hot-reload (DEV)
# - Réseau isolé
# - Profils: activer le frontend à la demande
# - Pas de container_name (évite les collisions)

# --- Réseau ---
networks:
  crm-network:
    driver: bridge

# --- Volumes ---
volumes:
  postgres-data:
  api-uploads:
  api-backups:
  api-logs:              # Logs persistants de l'API
  api-venv:              # Cache des dépendances Python
  frontend-node-modules: # Cache node_modules
  frontend-next:         # Cache du build Next.js

# --- Services ---
services:

  # ========================================
  # POSTGRES
  # ========================================
  postgres:
    image: postgres:16-alpine
    restart: unless-stopped
    environment:
      POSTGRES_USER: ${POSTGRES_USER:-crm_user}
      POSTGRES_PASSWORD: ${POSTGRES_PASSWORD:-crm_password}
      POSTGRES_DB: ${POSTGRES_DB:-crm_db}
      PGDATA: /var/lib/postgresql/data/pgdata
    command:
      - "postgres"
      - "-c"
      - "shared_buffers=128MB"
      - "-c"
      - "work_mem=4MB"
      - "-c"
      - "maintenance_work_mem=64MB"
      - "-c"
      - "effective_cache_size=512MB"
      - "-c"
      - "max_connections=50"
    ports:
      - "127.0.0.1:${POSTGRES_EXTERNAL_PORT:-5433}:5432"
    volumes:
      - postgres-data:/var/lib/postgresql/data
    networks:
      - crm-network
    healthcheck:
      test: ["CMD-SHELL", "pg_isready -h 127.0.0.1 -p 5432 -U ${POSTGRES_USER:-crm_user} -d postgres"]
      interval: 5s
      timeout: 3s
      retries: 20
      start_period: 20s
    logging:
      driver: "json-file"
      options: { max-size: "10m", max-file: "3" }

  # ========================================
  # API (FastAPI)
  # ========================================
  api:
    build:
      context: ./crm-backend
      dockerfile: Dockerfile
      target: ${BUILD_TARGET:-development}
    restart: unless-stopped
    depends_on:
      postgres:
        condition: service_healthy
      redis:
        condition: service_healthy
    # env_file:
      # - ./crm-backend/.env.local  # Plus utilisé, tout est dans .env racine
      # - ./.env   # Docker Compose charge automatiquement .env racine
    environment:
      # Fallbacks si non définis dans .env.local
      DATABASE_URL: ${DATABASE_URL:-postgresql://${POSTGRES_USER:-crm_user}:${POSTGRES_PASSWORD:-crm_password}@postgres:5432/${POSTGRES_DB:-crm_db}}
      # Redis Cache & Event Bus
      REDIS_ENABLED: ${REDIS_ENABLED:-True}
      REDIS_HOST: ${REDIS_HOST:-redis}
      REDIS_PORT: ${REDIS_PORT:-6379}
      REDIS_DB: ${REDIS_DB:-0}
      DEBUG: ${DEBUG:-True}
      SECRET_KEY: ${SECRET_KEY:-dev_secret_key_change_in_production}
      # Respecte .env (fallback inclut localhost + domaines publics)
      ALLOWED_ORIGINS: '${ALLOWED_ORIGINS:-["http://localhost:3010","http://127.0.0.1:3010","http://localhost:3000","https://crm.alforis.fr","https://staging.crm.alforis.fr"]}'
      JWT_ALGORITHM: ${JWT_ALGORITHM:-HS256}
      JWT_EXPIRATION_HOURS: ${JWT_EXPIRATION_HOURS:-24}
      ENVIRONMENT: ${ENVIRONMENT:-development}
      MAX_UPLOAD_SIZE_MB: ${MAX_UPLOAD_SIZE_MB:-10}
      API_PORT: ${API_PORT:-8000}
      WEBHOOK_SECRET: ${WEBHOOK_SECRET}
      UNSUBSCRIBE_JWT_SECRET: ${UNSUBSCRIBE_JWT_SECRET}
      POSTGRES_USER: ${POSTGRES_USER:-crm_user}
      POSTGRES_PASSWORD: ${POSTGRES_PASSWORD:-crm_password}
      POSTGRES_DB: ${POSTGRES_DB:-crm_db}
      POSTGRES_HOST: postgres
      # Encryption for API keys in DB
      ENCRYPTION_KEY: ${ENCRYPTION_KEY}
      # Microsoft OAuth (Outlook)
      MICROSOFT_CLIENT_ID: ${MICROSOFT_CLIENT_ID}
      MICROSOFT_CLIENT_SECRET: ${MICROSOFT_CLIENT_SECRET}
      MICROSOFT_REDIRECT_URI: ${MICROSOFT_REDIRECT_URI:-http://localhost:8000/api/v1/integrations/outlook/callback}
      PYTHONPATH: /app
    working_dir: /app
    # Command: Use Dockerfile CMD (dev=uvicorn reload, prod=supervisord)
    # Uncomment below for dev mode override:
    # command: sh -c "uvicorn main:app --host 0.0.0.0 --port ${API_PORT:-8000} --reload --reload-delay 2"
    ports:
      - "127.0.0.1:${API_PORT:-8000}:${API_PORT:-8000}"
    volumes:
      - ./crm-backend:/app:cached   # cached pour macOS (réduit les faux changements)
      - api-venv:/app/venv          # Volume nommé pour cache pip
      - api-uploads:/app/uploads
      - api-backups:/app/backups
      - api-logs:/app/logs          # Logs persistants
    networks:
      - crm-network
    # Healthcheck sans curl/wget (utilise Python disponible dans l'image)
    healthcheck:
      test: ["CMD-SHELL", "python -c 'import urllib.request,os;u=os.environ.get(\"API_PORT\",\"8000\");urllib.request.urlopen(f\"http://localhost:{u}/api/v1/health\")' || exit 1"]
      interval: 30s          # Réduit la fréquence (était 20s)
      timeout: 10s           # Plus de temps (était 5s)
      retries: 5             # Moins de retries (était 10)
      start_period: 60s      # Plus de temps au démarrage (était 40s)
    # Augmentation des file descriptors (évite problèmes WebSocket)
    ulimits:
      nofile:
        soft: 65536
        hard: 65536
    logging:
      driver: "json-file"
      options: { max-size: "10m", max-file: "3" }

  # ========================================
  # FRONTEND (Next.js) - activable à la demande
  # ========================================
  frontend:
    profiles: ["frontend"]  # → docker compose --profile frontend up -d
    build:
      context: ./crm-frontend
      dockerfile: Dockerfile
      target: development
    restart: unless-stopped
    depends_on:
      api:
        condition: service_started
    # env_file:
      # - ./crm-frontend/.env.local  # Plus utilisé, tout est dans .env racine
    environment:
      NEXT_PUBLIC_API_URL: ${NEXT_PUBLIC_API_URL:-http://localhost:${API_PORT:-8000}}
      PORT: ${FRONTEND_PORT:-3010}
      NODE_ENV: development
    working_dir: /app
    # Clean optionnel + lance Next sur le bon port (évite la boucle)
    command: >
      sh -euc '
        [ -f scripts/dev-clean.sh ] && chmod +x scripts/dev-clean.sh && ./scripts/dev-clean.sh || echo "skip dev-clean";
        exec npm run dev -- --port "${PORT:-3010}"
      '
    ports:
      - "127.0.0.1:${FRONTEND_PORT:-3010}:${FRONTEND_PORT:-3010}"
    volumes:
      - ./crm-frontend:/app:cached               # cached pour macOS
      - frontend-node-modules:/app/node_modules  # Volume nommé pour cache npm
      - frontend-next:/app/.next                 # Volume nommé pour cache build
    networks:
      - crm-network
    # Healthcheck via node (pas besoin de wget/curl)
    healthcheck:
      test: ["CMD-SHELL", "node -e 'require(\"http\").get(`http://localhost:${FRONTEND_PORT:-3010}`,r=>process.exit(r.statusCode>=200&&r.statusCode<500?0:1)).on(\"error\",()=>process.exit(1))'"]
      interval: 30s
      timeout: 10s
      retries: 5
      start_period: 60s
    # Augmentation des file descriptors (évite problèmes WebSocket + HMR)
    ulimits:
      nofile:
        soft: 65536
        hard: 65536
    logging:
      driver: "json-file"
      options: { max-size: "10m", max-file: "3" }

  # ========================================
  # REDIS (Cache & Celery Broker)
  # ========================================
  redis:
    image: redis:7-alpine
    restart: unless-stopped
    ports:
      - "6379:6379"        # optionnel en dev
    networks:
      - crm-network
    healthcheck:
      test: ["CMD-SHELL", "redis-cli ping | grep PONG"]
      interval: 5s
      timeout: 3s
      retries: 10
    logging:
      driver: "json-file"
      options: { max-size: "10m", max-file: "3" }

  # ========================================
  # CELERY WORKER (Background Tasks)
  # ========================================
  celery-worker:
    build:
      context: ./crm-backend
      dockerfile: Dockerfile
      target: ${BUILD_TARGET:-development}
    restart: unless-stopped
    depends_on:
      postgres:
        condition: service_healthy
      redis:
        condition: service_healthy
    environment:
      DATABASE_URL: ${DATABASE_URL:-postgresql://${POSTGRES_USER:-crm_user}:${POSTGRES_PASSWORD:-crm_password}@postgres:5432/${POSTGRES_DB:-crm_db}}
      REDIS_URL: ${REDIS_URL:-redis://redis:6379/0}
      REDIS_ENABLED: ${REDIS_ENABLED:-True}
      REDIS_HOST: ${REDIS_HOST:-redis}
      REDIS_PORT: ${REDIS_PORT:-6379}
      REDIS_DB: ${REDIS_DB:-0}
      SECRET_KEY: ${SECRET_KEY:-dev_secret_key_change_in_production}
      ENCRYPTION_KEY: ${ENCRYPTION_KEY}
      ENVIRONMENT: ${ENVIRONMENT:-development}
      POSTGRES_USER: ${POSTGRES_USER:-crm_user}
      POSTGRES_PASSWORD: ${POSTGRES_PASSWORD:-crm_password}
      POSTGRES_DB: ${POSTGRES_DB:-crm_db}
      POSTGRES_HOST: postgres
      PYTHONPATH: /app
    working_dir: /app
    command: celery -A celery_app worker --loglevel=info --concurrency=2 --max-tasks-per-child=100
    volumes:
      - ./crm-backend:/app:cached
      - api-venv:/app/venv
      - api-logs:/app/logs
    networks:
      - crm-network
    healthcheck:
      test: ["CMD-SHELL", "celery -A celery_app inspect ping || exit 1"]
      interval: 30s
      timeout: 10s
      retries: 3
      start_period: 60s
    logging:
      driver: "json-file"
      options: { max-size: "10m", max-file: "3" }

  # ========================================
  # CELERY BEAT (Periodic Task Scheduler)
  # ========================================
  celery-beat:
    build:
      context: ./crm-backend
      dockerfile: Dockerfile
      target: ${BUILD_TARGET:-development}
    restart: unless-stopped
    depends_on:
      postgres:
        condition: service_healthy
      redis:
        condition: service_healthy
      celery-worker:
        condition: service_started
    environment:
      DATABASE_URL: ${DATABASE_URL:-postgresql://${POSTGRES_USER:-crm_user}:${POSTGRES_PASSWORD:-crm_password}@postgres:5432/${POSTGRES_DB:-crm_db}}
      REDIS_URL: ${REDIS_URL:-redis://redis:6379/0}
      REDIS_ENABLED: ${REDIS_ENABLED:-True}
      REDIS_HOST: ${REDIS_HOST:-redis}
      REDIS_PORT: ${REDIS_PORT:-6379}
      REDIS_DB: ${REDIS_DB:-0}
      SECRET_KEY: ${SECRET_KEY:-dev_secret_key_change_in_production}
      ENCRYPTION_KEY: ${ENCRYPTION_KEY}
      ENVIRONMENT: ${ENVIRONMENT:-development}
      POSTGRES_USER: ${POSTGRES_USER:-crm_user}
      POSTGRES_PASSWORD: ${POSTGRES_PASSWORD:-crm_password}
      POSTGRES_DB: ${POSTGRES_DB:-crm_db}
      POSTGRES_HOST: postgres
      PYTHONPATH: /app
    working_dir: /app
    command: celery -A celery_app beat --loglevel=info --schedule=/tmp/celerybeat-schedule
    volumes:
      - ./crm-backend:/app:cached
      - api-venv:/app/venv
      - api-logs:/app/logs
    networks:
      - crm-network
    logging:
      driver: "json-file"
      options: { max-size: "10m", max-file: "3" }

  # ========================================
  # FLOWER (Celery Monitoring UI)
  # ========================================
  flower:
    build:
      context: ./crm-backend
      dockerfile: Dockerfile
      target: ${BUILD_TARGET:-development}
    restart: unless-stopped
    depends_on:
      redis:
        condition: service_healthy
      celery-worker:
        condition: service_started
    environment:
      REDIS_URL: ${REDIS_URL:-redis://redis:6379/0}
      CELERY_BROKER_URL: ${REDIS_URL:-redis://redis:6379/0}
      CELERY_RESULT_BACKEND: ${REDIS_URL:-redis://redis:6379/0}
      PYTHONPATH: /app
    working_dir: /app
    command: celery -A celery_app flower --port=5555
    ports:
      - "127.0.0.1:5555:5555"
    volumes:
      - ./crm-backend:/app:cached
      - api-venv:/app/venv
    networks:
      - crm-network
    healthcheck:
      test: ["CMD-SHELL", "wget --no-verbose --tries=1 --spider http://localhost:5555 || exit 1"]
      interval: 30s
      timeout: 10s
      retries: 3
      start_period: 30s
    logging:
      driver: "json-file"
      options: { max-size: "10m", max-file: "3" }
