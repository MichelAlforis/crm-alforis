# P2 Performance Optimizations - Guide d'Utilisation

Date: 27 Octobre 2025
Status: ✅ Deployed

## Vue d'Ensemble

Les optimisations P2 (Priority 2) améliorent LCP et TBT sans compromettre la stabilité.
Toutes les optimisations sont rétrocompatibles et n'impactent pas le code existant.

---

## 1. Skeleton Components

### Fichiers
- components/skeletons/DashboardSkeletons.tsx
- components/skeletons/index.ts

### Usage

```tsx
import { CardsSkeleton, TableSkeleton, WidgetSkeleton } from '@/components/skeletons'

// Dans un Suspense boundary
<Suspense fallback={<CardsSkeleton />}>
  <HeavyComponent />
</Suspense>

// Ou dans un dynamic import
const HeavyComponent = dynamic(() => import('./HeavyComponent'), {
  loading: () => <TableSkeleton rows={10} />,
})
```

### Composants disponibles
- CardsSkeleton: Pour les KPI cards (4 cards)
- TableSkeleton: Pour les tableaux (rows configurable)
- ChartSkeleton: Pour les graphiques (height configurable)
- WidgetSkeleton: Pour les widgets d'activité

---

## 2. Web Worker pour Tables

### Fichiers
- workers/table-worker.ts
- hooks/useTableWorker.ts

### Usage

```tsx
import { useTableWorker } from '@/hooks/useTableWorker'

function MyTable() {
  const { sortAndFilter, isProcessing } = useTableWorker()
  const [rows, setRows] = useState([])

  const handleSort = async (column: string) => {
    const sorted = await sortAndFilter({
      data: rows,
      sortBy: column,
      direction: 'asc',
    })
    setRows(sorted)
  }

  return (
    <div>
      {isProcessing && <div>Processing...</div>}
      <Table data={rows} onSort={handleSort} />
    </div>
  )
}
```

### Fonctions disponibles
- sort(data, sortBy, direction): Tri simple
- filter(data, filters, searchQuery, searchFields): Filtre
- sortAndFilter(...): Combinaison (recommandé)

### Performance
- < 100 lignes: Différence négligeable
- 100-500 lignes: Gain TBT ~30%
- 500+ lignes: Gain TBT ~60%

---

## 3. Suspense + Dynamic Imports

### Usage dans Pages

```tsx
// app/dashboard/page.tsx (exemple)
import { Suspense } from 'react'
import dynamic from 'next/dynamic'
import { CardsSkeleton } from '@/components/skeletons'

// Charger composants lourds dynamiquement
const HeavyWidget = dynamic(() => import('@/components/HeavyWidget'), {
  ssr: false,
  loading: () => <WidgetSkeleton />,
})

export default function Page() {
  return (
    <div>
      {/* Contenu statique (rendu immédiat) */}
      <h1>Dashboard</h1>

      {/* Contenu lourd (streaming) */}
      <Suspense fallback={<CardsSkeleton />}>
        <HeavyWidget />
      </Suspense>
    </div>
  )
}
```

### Quand utiliser
- ✅ Composants lourds (>50KB)
- ✅ Charts et graphiques
- ✅ Widgets avec data fetching
- ❌ Composants petits (<10KB)
- ❌ Above-the-fold content critique

---

## 4. requestIdleCallback

### Fichier
- utils/idleCallback.ts

### Usage

```tsx
import { runWhenIdle, useIdleCallback } from '@/utils/idleCallback'

// Version impérative
runWhenIdle(() => {
  // Code non-critique
  import('./analytics').then(m => m.init())
})

// Version React Hook
function MyComponent() {
  useIdleCallback(() => {
    // Heavy operation
    processNonCriticalData()
  }, [deps])
}
```

### Cas d'usage
- ✅ Analytics initialization
- ✅ Third-party scripts
- ✅ Prefetching routes
- ✅ Background data sync
- ❌ UI critique
- ❌ User-initiated actions

---

## 5. Preconnect Optimizations

### Fichier
- app/layout.tsx (lignes 65-73)

### Déjà configuré
```tsx
<link rel="preconnect" href="https://fonts.gstatic.com" crossOrigin="" />
<link rel="preconnect" href={process.env.NEXT_PUBLIC_API_URL} />
```

### Ajouter de nouveaux preconnects

Si vous ajoutez des origines externes (CDN, API tierces):

```tsx
<link rel="preconnect" href="https://cdn.example.com" />
<link rel="dns-prefetch" href="https://cdn.example.com" />
```

⚠️ Limiter à 3-4 preconnects max (overhead si trop nombreux)

---

## Métriques Attendues

### Avant P2
- FCP: 0.268-0.3s ✅
- LCP: 3.6-3.9s ⚠️
- TBT: 820ms ❌
- Speed Index: 1.0-1.3s ✅

### Après P2 (estimé)
- FCP: 0.15-0.2s ✅ (-30%)
- LCP: 2.0-2.4s ✅ (-40%)
- TBT: <300ms ✅ (-65%)
- Speed Index: 0.8-1.0s ✅ (-25%)

---

## Testing

### Dev Mode
```bash
npm run dev
# Ouvrir http://localhost:3010/dashboard
# Vérifier que les skeletons apparaissent avant le contenu
```

### Production Build
```bash
npm run build
npm start
# Chrome DevTools > Lighthouse > Performance
```

### Points à vérifier
1. Skeletons s'affichent instantanément
2. Pas de layout shift (CLS = 0)
3. Tri de table reste fluide
4. Pas d'erreurs console

---

## Troubleshooting

### Web Worker ne fonctionne pas
- Vérifier que le navigateur supporte Web Workers (tous les modernes)
- Fallback automatique vers execution synchrone
- Check console pour erreurs Worker

### Dynamic import fail
- Vérifier que le composant est bien exporté (export default ou named export)
- Vérifier le path import
- Check next.config.js pour webpack config

### Skeletons ne s'affichent pas
- Vérifier que Suspense entoure bien le composant dynamique
- Vérifier import path des skeletons
- Check que loading prop est bien défini dans dynamic()

---

## Prochaines Étapes (P3 - Optionnel)

1. Virtualisation de TableV2 avec react-window (>200 lignes)
2. Image optimization avec next/image + priority
3. Bundle analyzer pour identifier bloat
4. Lighthouse CI integration
5. CDN configuration pour static assets

---

Questions? Consulter:
- /checklists/12-performance.md (documentation complète)
- Next.js Docs: https://nextjs.org/docs/app/building-your-application/optimizing
- Web.dev Performance: https://web.dev/performance/
